---
title: "Version 6: Cluster first"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(ggmcmc)
library(dplyr)
library(gridExtra)
library(stringr)
library(fs)
devtools::load_all("clone.tools")
outdir <- file.path("..", "output", "dat_likelihood.Rmd")
modeldir <- file.path("..", "archive", "v6", "models")
dir_create(outdir)
```

## Simulate data

```{r sim}
I <- 30
K <- 3
S <- 3
set.seed(123)
pi <- rep(1/3, 3)
## 10 mutations for each of the 3 clusters
z <- rep(1:3, each=10)
w <- matrix(c(0.98, 0.99, 0.97, 
              0.55, 0.00, 0.80, 
              0.30, 0.70, 0.00),
            byrow=T,
            nrow=K, ncol=S)
dimnames(w) <-  list(paste0("cluster", seq_len(K)),
                     paste0("sample", 1:S))
w

tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), 
            nrow=I, ncol=S)
W <- w[z, ]
calcTheta <- function(m, tcn, w) {
  (m * w) / (tcn * w + 2*(1-w))
}

theta <- calcTheta(m, tcn, W)

n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
  for (s in 1:S) {
    y[i, s] <- rbinom(1, n[i, s], theta[i,s])
  }
}

test.data <- list("I" = I, "S" = S, "K" = K, 
                  "y" = y, "n" = n,
                  "m" = m, "tcn" = tcn)
```
# Visualize densities of simulated data

Clustering is by $\omega$

```{r simulated_densities, echo=F}
p <- test.data$y/test.data$n
colnames(w) <- colnames(p) <- paste0("sample", 1:S)
colnames(m) <- colnames(p)
m2 <- m %>%
    as_tibble() %>%
    mutate(z=factor(z),
           variant_index=seq_len(nrow(.))) %>%
    gather("sample", "multiplicity", -c(z, variant_index)) %>%
    mutate(sample=factor(sample, levels=colnames(p)))
p2 <- p %>%
    as_tibble() %>%
    mutate(z=factor(z),
           variant_index=seq_len(nrow(.))) %>%
    gather("sample", "fraction", -c(z, variant_index)) %>%
    mutate(sample=factor(sample, levels=colnames(p))) %>%
    left_join(m2, by=c("z", "variant_index", "sample")) %>%
    mutate(multiplicity=factor(multiplicity))
## what the data looks like by sample
ggplot(p2, aes(z, fraction)) +
    geom_jitter(width=0.1, size=1, aes(color=multiplicity)) +
    facet_wrap(~sample) +
    ylab("y/n") +
    xlab("True cluster") +
    theme(panel.background=element_rect(fill="white", color="black"))
## by variant
ggplot(p2, aes(sample, fraction, group=variant_index)) +
    geom_point(size=1) +
    geom_line(aes(color=z)) +
    ylab("y/n") +
    xlab("Patient sample\n(arbitrary order)") +
    theme(axis.text.x=element_text(angle=45, hjust=1)) +
    guides(color=guide_legend(title="Variant cluster\n(z)"))
##
## Cluster means and variances
##
meds   <- apply(W, 2, median)
slevels <- colnames(w)[order(meds, decreasing=TRUE)]
w2 <- w %>%
    as_tibble() %>%
    mutate(z=factor(1:K)) %>%
    ##       variant_index=seq_len(nrow(.))) %>%
    gather("sample", "omega", -z) %>%
    mutate(sample=factor(sample, levels=slevels))
fig2 <- ggplot(w2, aes(sample, omega, group=z)) +
    geom_point(size=1,  aes(color=z)) +
    geom_line(aes(color=z)) +
    ylab(expression(omega)) +
    xlab("") +
    theme(axis.text.x=element_text(angle=45, hjust=1),
          panel.background=element_rect(fill="white", color="black"),
          legend.key=element_rect(fill="white", color="white")) +
    guides(color=guide_legend(title="Variant cluster\n(z)"))
fig2
```

## Cluster -- JAGS

```{r JAGS}
jags.file <- file.path(modeldir, "w.jags")
inits <- list(".RNG.name" = "base::Wichmann-Hill", 
              ".RNG.seed" = 123)
test.data <- list("I" = I, "S" = S, 
                  "y" = y, "n" = n,
                  "m" = m, "tcn" = tcn)
params <- c("z", "w", "ystar")
n.iter = 10000
thin = 2
samps <- runMCMC(test.data, K, jags.file, inits, params, n.iter, thin)
## w indices:  cluster, sample
##jags_df <- ggs(samps)
##w.chain <- jags_df[grep("w", jags_df$Parameter), ] %>%
##    mutate(cluster_index=clusterIndex(Parameter),
##           sample_index=sampleIndex(Parameter))
##z.chain <- jags_df[grep("z", jags_df$Parameter), ] %>%
##    mutate(mutation_index=mutationIndex(Parameter))
z.chain <- getParamChain(samps, "z")
w.chain <- getParamChain(samps, "w")
mcmc_vals <- summary(samps)$statistics
mcmc_w <- mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "w", "Mean"]
mcmc_w <- matrix(mcmc_w, nrow=K)
colnames(mcmc_w) <- paste0("sample", 1:S)
```

## Posterior predictive distribution

```{r ppd, echo=F}
plot_ppd(samps, test.data, K)
```

## Z

```{r zplot, echo=TRUE, eval=TRUE}
source("cluster_first_k10_functions.R")
##trace(z.chain.to.tb, browser)
z.chain.tb <- z.chain.to.tb(z.chain)
z.chain.tb
nc <- ncol(z.chain)
z.seg.tb <- matrix(NA, nrow=nc, ncol=3)
colnames(z.seg.tb) <- c("variant", "mcmc_z_1", "mcmc_z_2")
for (i in 1:ncol(z.chain)) {
  z.vals <- as.integer(names(table(z.chain[,i])))
  if (length(z.vals) > 1) {
      z.seg.tb[i, ] <- c(i, z.vals[1], z.vals[2])
  } else {
    z.seg.tb[i, ] <- c(i, z.vals, z.vals) 
  }
}
z.seg.tb <- as_tibble(z.seg.tb)
## Plot cluster assignment (y-axis) versus variant index
z.plot <- ggplot(z.chain.tb, aes(variant_index, mcmc_z)) +
  ylab("mcmc z") + 
  xlab("variant") +
  theme_light() +
  scale_y_continuous(breaks = 1:K, minor_breaks=NULL) +
  ##scale_x_continuous(breaks = seq(10,100,10), minor_breaks=NULL) +
  geom_segment(data = z.seg.tb, 
               aes(x=variant, xend=variant,
                   y=mcmc_z_1, yend=mcmc_z_2),
                   color="gray", linetype=2) +
  geom_point(aes(y=mcmc_z, fill=prop), 
             pch=21, size=3, stroke=0)
z.plot
```

```{r map} 
z.map.tb <- z.chain.tb %>%
  group_by(variant) %>%
  filter(prop == max(prop))
z.map.tb
z.map <- z.map.tb$mcmc_z
z.map
z.map.ind <- which(apply(z.chain, 1, function(x) all(x == z.map)))
w.chain.map <- w.chain[z.map.ind, ]
w.map.tb <- w.chain.map %>%
  as_tibble() %>%
  mutate(iter=1:nrow(w.chain.map)) %>%
  gather(ind, mcmc_w, -c(iter)) %>%
  group_by(ind) %>%
  summarize(mean_w = mean(mcmc_w))
w.map.tb <- w.map.tb %>%
  mutate(cluster = as.integer(gsub(".*\\[(.*)\\,.*", "\\1", w.map.tb$ind))) %>%
  mutate(sample = as.integer(gsub(".*\\,(.*)\\]", "\\1", w.map.tb$ind))) %>%
  arrange(cluster)
#w.map.tb
w.map <- matrix(data=w.map.tb$mean_w, nrow=K, ncol=3, byrow=TRUE)
dimnames(w.map) <- list(paste0("cluster", seq_len(K)),
                        paste0("sample", seq_len(ncol(w.map))))
w.map
```

## Adjacency matrix

```{r admat_functions}
source("cluster_first_k10_functions.R")
```

```{r admat_score} 
A <- base.admat(w, zero.thresh = 0.01)
rownames(A) <- c("root", rownames(w.map))
colnames(A) <- rownames(w.map)
## True adjacency matrix
A[1, 1] <- A[2, 2] <- A[2, 3] <- 1
A
## TODO: unit test this
score.admat(A, w)
```

```{r tree_mcmc}
set.seed(1234)
mcmc_vals <- summary(samps)$statistics
mcmc_w <- mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "w", "Mean"]
mcmc_w <- matrix(mcmc_w, nrow=K)
colnames(mcmc_w) <- paste0("sample", 1:S)

##
## Let's switch back the labels so that it corresponds to the simulated MCFs 
##'
mcmc_w <- mcmc_w[c(1, 3, 2), ]
dimnames(mcmc_w) <- dimnames(w)
round(mcmc_w, 2)

##A2 <- base.admat(mcmc_w)
Ainit <- A ## start at truth
score.admat.chain(Ainit, w.chain)

numIter <- 1000
nSamples <- ncol(w)
A.chain <- matrix(NA, numIter, (K+1)*nSamples)
A.chain[1, ] <- as.numeric(init.admat(mcmc_w, zero.thresh=0.01))
numAccept  <-  0


for (i in seq_len(numIter)) {
    am <- matrix(A.chain[i, ], (K+1), nSamples)
    ##P.prev <- score.admat.chain(am, w.chain)
    source("cluster_first_k10_functions.R")
    trace(scoreA, browser)
    P.prev <- scoreA(am, w=w.chain[i, , drop=FALSE])
    score.chain[i] <- P.prev
    #admat.star <- mutate.admat(admat.chain[[i]])
    #P.star <- score.admat.chain(admat.star, w.chain)

    # if(P.prev == 0 & P.star == 0) {
    #   admat.chain[[i+1]] <- admat.star
    #   numAccept <- numAccept + 1
    #   next
    # }
    P.star <- 0
    while (P.star == 0) {
        admat.star <- mutate.admat(admat.chain[[i]])
        trace(score.admat.chain, browser)
        P.star <- score.admat.chain(admat.star, w.chain)
    }

    r <- P.star / P.prev
    u <- runif(1,0,1)
    if(u <= r) {
      admat.chain[[i+1]] <- admat.star
      numAccept <- numAccept + 1
    } else {
      admat.chain[[i+1]] <- admat.chain[[i]]
    }
}
score.chain[i+1] <- score.admat.chain(admat.chain[[i+1]], w.chain)
acceptRate <- numAccept/(numIter)
acceptRate

plot(score.chain)
max(score.chain)
max.score.ind <- which(score.chain == max(score.chain))
if(length(max.score.ind) > 1) max.score.ind <- max.score.ind[1]
max.admat <- admat.chain[[max.score.ind]]
max.admat
```

