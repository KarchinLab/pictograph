---
title: "Version 6: Cluster first"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(ggmcmc)
library(dplyr)
library(gridExtra)
library(stringr)
library(fs)
devtools::load_all("clone.tools")
outdir <- file.path("..", "output", "dat_likelihood.Rmd")
modeldir <- file.path("..", "archive", "v6", "models")
dir_create(outdir)
```

## Simulate data

```{r sim}
I <- 100
K <- 10
S <- 3

set.seed(123)

pi <- rep(0.1, 10)
#z <- sample(1:K, size = I, replace = T, prob = pi)
z <- rep(1:10, each=10)
##
## each row is a cluster of mutations
##
## columns are samples
w <- matrix(c(0.98, 0.99, 0.97, 
              0.98, 0.90, 0.82,
              0.55, 0.00, 0.80, 
              0.20, 0.00, 0.50,
              0.30, 0.00, 0.30, 
              0.43, 0.90, 0.00,
              0.30, 0.70, 0.00,
              0.20, 0.00, 0.00,
              0.00, 0.00, 0.30,
              0.00, 0.50, 0.00),
            byrow=T,
            nrow=K, ncol=S)

colnames(w) <-  paste0("sample", 1:S)
w

tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), 
            nrow=I, ncol=S)
W <- w[z, ]
calcTheta <- function(m, tcn, w) {
  (m * w) / (tcn * w + 2*(1-w))
}

theta <- calcTheta(m, tcn, W)

n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
  for (s in 1:S) {
    y[i, s] <- rbinom(1, n[i, s], theta[i,s])
  }
}

test.data <- list("I" = I, "S" = S, "K" = K, 
                  "y" = y, "n" = n,
                  "m" = m, "tcn" = tcn)
```
# Visualize densities of simulated data

Clustering is by $\omega$

```{r simulated_densities, echo=F}
p <- test.data$y/test.data$n
colnames(w) <- colnames(p) <- paste0("sample", 1:S)
colnames(m) <- colnames(p)
m2 <- m %>%
    as_tibble() %>%
    mutate(z=factor(z),
           variant_index=seq_len(nrow(.))) %>%
    gather("sample", "multiplicity", -c(z, variant_index)) %>%
    mutate(sample=factor(sample, levels=colnames(p)))
p2 <- p %>%
    as_tibble() %>%
    mutate(z=factor(z),
           variant_index=seq_len(nrow(.))) %>%
    gather("sample", "fraction", -c(z, variant_index)) %>%
    mutate(sample=factor(sample, levels=colnames(p))) %>%
    left_join(m2, by=c("z", "variant_index", "sample")) %>%
    mutate(multiplicity=factor(multiplicity))
## what the data looks like by sample
ggplot(p2, aes(z, fraction)) +
    geom_jitter(width=0.1, size=1, aes(color=multiplicity)) +
    facet_wrap(~sample) +
    ylab("y/n") +
    xlab("True cluster") +
    theme(panel.background=element_rect(fill="white", color="black"))
## by variant
ggplot(p2, aes(sample, fraction, group=variant_index)) +
    geom_point(size=1) +
    geom_line(aes(color=z)) +
    ylab("y/n") +
    xlab("Patient sample\n(arbitrary order)") +
    theme(axis.text.x=element_text(angle=45, hjust=1)) +
    guides(color=guide_legend(title="Variant cluster\n(z)"))
##
## Cluster means and variances
##
meds   <- apply(W, 2, median)
slevels <- colnames(w)[order(meds, decreasing=TRUE)]
w2 <- w %>%
    as_tibble() %>%
    mutate(z=factor(1:K)) %>%
    ##       variant_index=seq_len(nrow(.))) %>%
    gather("sample", "omega", -z) %>%
    mutate(sample=factor(sample, levels=slevels))
fig2 <- ggplot(w2, aes(sample, omega, group=z)) +
    geom_point(size=1,  aes(color=z)) +
    geom_line(aes(color=z)) +
    ylab(expression(omega)) +
    xlab("") +
    theme(axis.text.x=element_text(angle=45, hjust=1),
          panel.background=element_rect(fill="white", color="black"),
          legend.key=element_rect(fill="white", color="white")) +
    guides(color=guide_legend(title="Variant cluster\n(z)"))
fig2
```

## functions
```{r func, eval=FALSE}
runMCMC <- function(data, K, jags.file, inits, params, n.iter, thin) {
  data$K <- K
  jags.m <- jags.model(jags.file, data,
                       n.chains = 1,
                       inits = inits,
                       n.adapt = 1000)
  samps <- coda.samples(jags.m, params, n.iter=n.iter, thin=thin)
  samps
}

getParamChain <- function(samps, param) {
  chains <- do.call(rbind, samps)
  chain <- chains[, grep(param, colnames(chains))]
}

reshapeW <- function(w, S, K) {
  w.mat <- matrix(w, nrow = K)
  colnames(w.mat) <- paste0("sample", 1:S)
  w.mat
}

calcLogLik <- function(z.iter, w.iter, data) {
  W <- w.iter[z.iter, ]
  theta <- calcTheta(data$m, data$tcn, W)
  sum(dbinom(data$y, data$n, theta, log=T))
}

calcChainLogLik <- function(samps, data, K) {
  z.chain <- getParamChain(samps, "z")
  w.chain <- getParamChain(samps, "w")
  lik <- c()
  for(iter in 1:nrow(z.chain)) {
    z.iter <- z.chain[iter,]
    w.iter <- reshapeW(w.chain[iter,], data$S, K)
    lik <- c(lik, calcLogLik(z.iter, w.iter, data))
  }
  mean(lik)
}

calcBIC <- function(n, k, ll) log(n)*k - 2*ll
```

## Cluster -- JAGS

```{r JAGS}
jags.file <- file.path(modeldir, "w.jags")
inits <- list(".RNG.name" = "base::Wichmann-Hill", 
              ".RNG.seed" = 123)
test.data <- list("I" = I, "S" = S, 
                  "y" = y, "n" = n,
                  "m" = m, "tcn" = tcn)
params <- c("z", "w", "ystar")
n.iter = 10000
thin = 7
K <- 10
samps <- runMCMC(test.data, K, jags.file, inits, params, n.iter, thin)

clusterIndex <- function(x){
    as.character(x) %>%
        strsplit("[", fixed=TRUE) %>%
        sapply("[", 2) %>%
        strsplit(",") %>%
        sapply("[", 1) %>%
        as.integer()
}
sampleIndex <- function(x){
    as.character(x) %>%
        strsplit(",", fixed=TRUE) %>%
        sapply("[", 2) %>%
        str_replace("]", "") %>%
        as.integer()
}

mutationIndex <- function(x){
    as.character(x) %>%
        strsplit("[", fixed=TRUE) %>%
        sapply("[", 2) %>%
        str_replace("]", "") %>%
        as.integer()
}

## w indices:  cluster, sample
jags_df <- ggs(samps)
w.chain <- jags_df[grep("w", jags_df$Parameter), ] %>%
    mutate(cluster_index=clusterIndex(Parameter),
           sample_index=sampleIndex(Parameter))
z.chain <- jags_df[grep("z", jags_df$Parameter), ] %>%
    mutate(mutation_index=mutationIndex(Parameter))
z.chain <- getParamChain(samps, "z")
w.chain <- getParamChain(samps, "w")
mcmc_vals <- summary(samps)$statistics
mcmc_w <- mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "w", "Mean"]
mcmc_w <- matrix(mcmc_w, nrow=K)
colnames(mcmc_w) <- paste0("sample", 1:S)
```

## Posterior predictive distribution

```{r ppd, echo=F}
plot_ppd(samps, test.data, K)
```

## Z

```{r zplot, echo=TRUE, eval=TRUE}
plot.z <- function(samps, z) {
  mcmc_vals <- summary(samps)$statistics
  mcmc_z <- as.vector(mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "z", "Mean"])
  plot(z, mcmc_z, type = "p")
  z_comp <- data.frame(z, mcmc_z)
}
z.chain.to.tb <- function(z.chain) {
  z.chain.tb <- z.chain %>%
    as_tibble() %>%
    mutate(iter=1:nrow(z.chain)) %>%
    gather(variant, mcmc_z, -c(iter)) 
  z.chain.tb <- z.chain.tb %>%
    mutate(variant = as.integer(gsub(".*\\[(.*)\\].*", "\\1", z.chain.tb$variant))) %>%
    mutate(true_z = rep(1:10, each=nrow(z.chain)*10)) %>%
    group_by(variant, mcmc_z) %>% 
    mutate(count = n())
  z.chain.tb_simp <- distinct(select(z.chain.tb, -c(iter)))
  z.chain.tb_simp %>% 
    group_by(variant) %>%
    mutate(prop = count/sum(count))
}
z.chain.tb <- z.chain.to.tb(z.chain)
z.chain.tb

nc <- ncol(z.chain)
z.seg.tb <- matrix(NA, nrow=nc, ncol=3)
colnames(z.seg.tb) <- c("variant", "mcmc_z_1", "mcmc_z_2")
for (i in 1:ncol(z.chain)) {
  z.vals <- as.integer(names(table(z.chain[,i])))
  if (length(z.vals) > 1) {
      z.seg.tb[i, ] <- c(i, z.vals[1], z.vals[2])
  } else {
    z.seg.tb[i, ] <- c(i, z.vals, z.vals) 
  }
}
z.seg.tb <- as_tibble(z.seg.tb)
#z.seg.tb
z.plot <- ggplot(z.chain.tb, aes(variant, mcmc_z)) +
  ylab("mcmc z") + 
  xlab("variant") +
  theme_light() +
  scale_y_continuous(breaks = 1:K, minor_breaks=NULL) +
  scale_x_continuous(breaks = seq(10,100,10), minor_breaks=NULL) +
  geom_segment(data = z.seg.tb, 
               aes(x=variant, xend=variant,
                   y=mcmc_z_1, yend=mcmc_z_2),
                   color="gray", linetype=2) +
  geom_point(aes(y=mcmc_z, fill=prop), 
             pch=21, size=3, stroke=0)
z.plot
```

```{r map} 
z.map.tb <- z.chain.tb %>%
  group_by(variant) %>%
  filter(prop == max(prop))
z.map.tb
z.map <- z.map.tb$mcmc_z
z.map
z.map.ind <- which(apply(z.chain, 1, function(x) all(x == z.map)))
w.chain.map <- w.chain[z.map.ind, ]
w.map.tb <- w.chain.map %>%
  as_tibble() %>%
  mutate(iter=1:nrow(w.chain.map)) %>%
  gather(ind, mcmc_w, -c(iter)) %>%
  group_by(ind) %>%
  summarize(mean_w = mean(mcmc_w))
w.map.tb <- w.map.tb %>%
  mutate(cluster = as.integer(gsub(".*\\[(.*)\\,.*", "\\1", w.map.tb$ind))) %>%
  mutate(sample = as.integer(gsub(".*\\,(.*)\\]", "\\1", w.map.tb$ind))) %>%
  arrange(cluster)
#w.map.tb
w.map <- matrix(data=w.map.tb$mean_w, nrow=10, ncol=3, byrow=TRUE)
w.map
```

## Adjacency matrix

```{r admat_functions}
source("cluster_first_k10_functions.R")
```

```{r admat_score} 
true.admat <- base.admat(w, zero.thresh = 0.01)
true.admat[1,1] <- true.admat[2,2] <- true.admat[3,3] <-  true.admat[3,6] <-
  true.admat[4,4] <- true.admat[4,5] <- true.admat[5,8] <- true.admat[6,9] <-
  true.admat[7,7] <- true.admat[8,10] <- 1
true.admat

score.admat(true.admat, w)
```

```{r tree_mcmc}
set.seed(1234)
mcmc_vals <- summary(samps)$statistics
mcmc_w <- mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "w", "Mean"]
mcmc_w <- matrix(mcmc_w, nrow=K)
colnames(mcmc_w) <- paste0("sample", 1:S)

answer <- base.admat(mcmc_w)
answer[1,1] <- answer[2,2] <- answer[3,7] <- answer[3,8] <- 
  answer[5,3] <- answer[8,9] <- answer[9,4] <- answer[9,10] <- 
  answer[10,5] <- answer[11,6] <- 1

score.admat.chain(answer, w.chain)

admat.chain <- list(init.admat(mcmc_w, zero.thresh=0.01))
score.chain <- c()

numAccept = 0
#2*2*6*5*8*4*5*4*5
numIter <- 1000
for (i in 1:numIter) {
  P.prev <- score.admat.chain(admat.chain[[i]], w.chain)
  score.chain[i] <- P.prev
  #admat.star <- mutate.admat(admat.chain[[i]])
  #P.star <- score.admat.chain(admat.star, w.chain)
  
  # if(P.prev == 0 & P.star == 0) {
  #   admat.chain[[i+1]] <- admat.star
  #   numAccept <- numAccept + 1
  #   next
  # }
  P.star <- 0
  while (P.star == 0) {
      admat.star <- mutate.admat(admat.chain[[i]])
      trace(score.admat.chain, browser)
      P.star <- score.admat.chain(admat.star, w.chain)
  }
  
  r <- P.star / P.prev
  u <- runif(1,0,1)
  if(u <= r) {
    admat.chain[[i+1]] <- admat.star
    numAccept <- numAccept + 1
  } else {
    admat.chain[[i+1]] <- admat.chain[[i]]
  }
}
score.chain[i+1] <- score.admat.chain(admat.chain[[i+1]], w.chain)
acceptRate <- numAccept/(numIter)
acceptRate

plot(score.chain)
max(score.chain)
max.score.ind <- which(score.chain == max(score.chain))
if(length(max.score.ind) > 1) max.score.ind <- max.score.ind[1]
max.admat <- admat.chain[[max.score.ind]]
max.admat
```

