---
title: "IP30 analysis -- tree MH"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(ggmcmc)
library(gridExtra)
library(stringr)
library(fs)
library(devtools)
library(tidyverse)
library(ggnet)
library(network)
library(sna)
devtools::load_all(file.path("..", "code", "clone.tools"))

outdir <- file.path("..", "output", "IP30.Rmd")
dir_create(outdir)

data.dir <- file.path("..", "data")

```

## Clustering data
```{r}
samps.list <- readRDS(file.path(outdir, "samps.list.rds"))
K <- 10
kToTest <- 5:15
samps <- samps.list[[which(kToTest == K)]] 
chains <- ggs(samps) 

z.chain <- chains[grep("z", chains$Parameter), ]
w.chain <- chains[grep("w", chains$Parameter), ]

mcf_stats <- w.chain %>%
    group_by(Parameter) %>%
    summarize(sd=sd(value),
              mean=mean(value))
```

# MH-sampler for tree

```{r tree_mcmc}
set.seed(1234)

cpov <- create.cpov(mcf_stats = mcf_stats)

# Initialize chain ------------------------------------------------------------

admat.chain <- list(rand.admat(initializeAdjacencyMatrix(mcf_stats = mcf_stats, zero.thresh = 0.01)))
score.chain <- calc.tree.fitness(admat.chain[[1]], cpov, mcfMatrix(mcf_stats))

# MCMC ------------------------------------------------------------------------

numAccept  <-  0
ncol.to.mutate <- 1 
numIter <- 1000

for (i in seq_len(numIter)) {
    fit.prev <- score.chain[i]

    ##
    ## Propose edge
    ##
    admat.star <- mutate.admat(admat.chain[[i]], ncol.to.mutate)
    #proposed <- plotDAG(admat.star)
    fit.star <- calc.tree.fitness(admat.star, cpov, mcfMatrix(mcf_stats))
    r <- fit.star / fit.prev
    u <- runif(1, 0, 1)    
    if(u <= r) {
        admat.chain[[i+1]] <- admat.star
        numAccept <- numAccept + 1
        accept[i] <- 1
        score.chain <- c(score.chain, fit.star)
    } else {
        admat.chain[[i+1]] <- admat.chain[[i]]
        score.chain <- c(score.chain, fit.prev)
    }
}
results <- list(admat.chain=admat.chain,
                score.chain=score.chain,
                numAccept=numAccept)
saveRDS(results, file.path("..", "output", "IP30.Rmd", "trees.rds"))

##
## posterior distribution of trees
##
numericRepresentation <- function(x){
    x[is.na(x)] <- 0
    x <- as.numeric(x)
    paste(x, collapse="")
}
trees <- sapply(admat.chain, numericRepresentation)
tab <- table(trees)
length(tab)
freq <- as.numeric(tab)
prob <- freq/1000
plot(prob)
tab2 <- tab[prob > 0.01]
## is the true tree among those with highest probability
tr <- numericRepresentation(answer)
tr %in% names(tab2)



acceptRate <- numAccept/(numIter)
acceptRate

max(score.chain)
max.score.ind <- which(score.chain == max(score.chain))
if(length(max.score.ind) > 1) max.score.ind <- max.score.ind[1]
max.admat <- admat.chain[[max.score.ind]]
max.admat

plotDAG(max.admat)
```
