---
title: "Extension 1: 1 clone with normal contamination"
output: pdf_document
---

```{r setup, include=FALSE}
library(knitr)
library(gridExtra)
opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=70),tidy=TRUE)
#opts_chunk$set(fig.width=5, fig.height=3.3) 
opts_chunk$set(fig.width=7, fig.height=4) 
```
# Variables
$\pi = \text{proportion of het variants} \sim \text{Beta}(1,1)$ 

$z = \text{zygosity indicator} = 
  \begin{cases}
    0 & \text{if  het}\\
    1 & \text{if  hom}
    \end{cases} \sim \text{Bernoulli}(1-\pi)$

$\theta =$ VAF of het variants $\in [0, 0.5]$

$n = \text{total number of reads} \sim \text{Poisson(average coverage)}$

$y = \text{number of variant reads}
  \begin{cases}
    \sim \text{Binomial}(n, \theta) & \text{if  het}\\
    \sim \text{Binomial}(n, 2\theta) & \text{if  hom}
  \end{cases}$
  
# Generate example data set

```{r generatedata, echo=F}
set.seed(1234)
pi <- 0.8 
n <- rpois(100, 50) 
theta <- 0.35
z <- rbinom(100, 1, (1-pi)) 
sampleY <- function(n, theta) {rbinom(1, n, theta)}
het <- mapply(sampleY, n, theta)
hom <- mapply(sampleY, n, theta*2)
y <- ifelse(z==0, het, hom)
obs_vaf <- round(y/n, 2)
data <- rbind(z, n, y, obs_vaf)
```

Note: All positions are diploid

$\pi = 0.8 \\ \theta = 0.35$

$z_i \sim \text{Bernoulli}(1-\pi)$ 
```{r, echo = F} 
z
```

$n_i \sim \text{Poisson(50)}$ 
```{r, echo = F} 
n
```

$y_i \sim \text{Binomial}(n_i, \theta)$ 
```{r, echo = F} 
y
```

```{r obs_vafs, echo=F}
het_vafs <- obs_vaf[which(z==0)]
hom_vafs <- obs_vaf[which(z==1)]
hist(het_vafs, col=rgb(1,0,0,0.5),xlim=c(0,1), ylim=c(0,40), main="Observed VAFs", xlab="VAF")
hist(hom_vafs, col=rgb(0,0,1,0.5), add=T)
```

# Gibbs sampler with MH update for theta

##Some formulas

```{r formulas}
# full conditional probability of theta 
Ptheta <- function(theta, y, n, z, alpha_0, beta_0) {
  het.ind <- which(z==0, arr.ind=T)
  hom.ind <- which(z==1, arr.ind=T)
  sum(dbinom(y[het.ind], n[het.ind], theta, log=TRUE)) +
    sum(dbinom(y[hom.ind], n[hom.ind], 2*theta, log=TRUE)) +
    dbeta(theta, alpha_0, beta_0, log = TRUE)
}

pistar <- function(yi, ni, theta, pi) {
  dbinom(yi, ni, theta) * pi / (dbinom(yi, ni, theta) * pi + dbinom(yi, ni, theta*2) * (1-pi))
}
```

##Parameters

```{r param}
S <- 1000 # number of iterations
alpha_0 <- 2 # prior for theta
beta_0 <- 2 # prior for theta
delta <- 0.03 # MH tuning parameter

pi_gibbs <- rep(NA, S)
pi_star <- matrix(NA, nrow = S, ncol = length(n))
z_gibbs <- matrix(NA, nrow = S, ncol = length(n))
theta_mh <- rep(NA, S)
```

## MCMC 
Tune $\delta$ so that acceptance rate is between 0.2 and 0.4. If acceptance rate is too large, then delta is too small. Conversely, if acceptance rate is too small, then delta is too large. 
$\\$
```{r run}
# starting values
pi_gibbs[1] <- runif(1, min = 0, max = 1) # starting value from uniform prior
theta_mh[1] <- rbeta(1, shape1 = alpha_0, shape2 = beta_0) # initialize from beta prior
if(theta_mh[1] > 0.5) theta_mh[1] <- theta_mh[1]/2
for (i in 1:length(n)) {
  pi_star[1, i] <- pistar(y[i], n[i], theta_mh[1], pi_gibbs[1])
  z_gibbs[1, i] <- rbinom(n=1, size=1, prob=(1-pi_star[1, i]))
}

# run
numAccept = 0
for (j in 2:S) {
  pi_gibbs[j] <- rbeta(n=1, shape1 = sum(1-z_gibbs[j-1, ])+1, shape2 = sum(z_gibbs[j-1, ])+1)
  
  for (i in 1:length(n)) {
    pi_star[j, i] <- pistar(y[i], n[i], theta_mh[j-1], pi_gibbs[j])
    z_gibbs[j, i] <- rbinom(n=1, size=1, prob=(1-pi_star[j, i]))
  }
  
  theta.star <- runif(1, theta_mh[j-1] - delta, theta_mh[j-1] + delta)
  if(theta.star < 0) theta.star <- abs(theta.star)
  if(theta.star > 0.5) theta.star <- theta.star - 0.5
  #theta.star <- runif(1, min(0, theta_mh[j-1] - delta), max(0.5, theta_mh[j-1] + delta))
  
  P.theta.star <- Ptheta(theta.star, y, n, z_gibbs[j, ], alpha_0, beta_0)
  P.theta.prev <- Ptheta(theta_mh[j-1], y, n, z_gibbs[j-1, ], alpha_0, beta_0)
  r <- P.theta.star - P.theta.prev
  
  u <- runif(1,0,1)
  if(log(u) <= r) {
    theta_mh[j] <- theta.star
    numAccept <- numAccept + 1
  } else {
    theta_mh[j] <- theta_mh[j-1]
  }
}
acceptRate <- numAccept/(S-1)
```

With $\delta$ = `r delta`, acceptance rate = `r acceptRate`.

## Results
# $\theta$
```{r theta, echo = F}
plot.ts(theta_mh, ylab="", main="Trace")

plot(density(theta_mh), main=" ")
```

# $\pi$
```{r pi, echo=F}
plot.ts(pi_gibbs, ylab="", main="Trace")

plot(density(pi_gibbs), main=" ")
```

# $z$
```{r z, echo=F}
z_df <- rbind(z = z, sum.z.gibbs = colSums(z_gibbs))
z_df
```