models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=7000, thin = 5)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=7000, thin = 7)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=7000, thin = 8)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=7000, thin = 7)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=6000, thin = 6)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
working.dir <- "~/Google Drive/lab/ipmn-progression/bayes-cluster/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S2"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S2 <- n[ , 2]
y_S2 <- y[ , 2]
m_S2 <- m[ , 2]
tcn_S2 <- tcn[ , 2]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S2, "n" = n_S2,
"m" = m_S2, "tcn" = tcn_S2)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1)
params <- c("z", "w", "U", "V")
#update(jags.m, n.iter=1000)
samps <- coda.samples(jags.m, params, n.iter=6000, thin = 6)
effectiveSize(samps)
s <- summary(samps)
s
mcmc_vals <- s$statistics
mcmc_w <- mcmc_vals[substr(rownames(mcmc_vals), 1, 1) == "w", "Mean"]
plot(as.vector(w), mcmc_w, type = "p")
mcmc_w
w
a
?abline
??mcmc_trace
