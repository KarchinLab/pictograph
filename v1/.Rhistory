library(rjags)
library(coda)
library(MCMCpack)
?jags.model
I <- 50
K <- 4
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
a
U <- a/(a+b)
V <- a+b
working.dir <- "~/Dropbox/Wood-Collab-Progression/clustering/v3"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v3_uv_unif_K4_2-10_trueStart"
jags.file <- file.path(models.dir, "v3_uv_unif.jags")
test.data <- list("I" = I, "S" = S, "K" = K,
"y" = y, "n" = n,
"m" = m, "tcn" = tcn)
trueVals <- list(z = z, w = w, U = U, V = V)
trueVals
w
w[2,7]
min(w)
which(w < 0.05)
U
V
z
U
z
U.ordered <- U[order(U[,1]), ]
U.ordered
order(U[,1])
trueVals$w
str(trueVals)
U
s = 1
U[,s]
allU <- rbind(U[,1], U[,2]
)
allU
as.vector(allU)
?round
working.dir <- "~/Dropbox/Wood-Collab-Progression/clustering/v2"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v2_uv_unif_S4"
I <- 50
K <- 2
S <- 10
# choose diffuse priors for gamma
a_gamma <- 2
b_gamma <- 10
avrg <- a_gamma * b_gamma
std.dv <- sqrt(a_gamma*b_gamma^2)
g_range = seq(0, avrg + 5*std.dv, 0.01)
g_y = dgamma(g_range, a_gamma, rate = 1/b_gamma)
#plot(g_range, g_y, type = "l", ylim=c(0, max(g_y) + 0.01))
set.seed(123)
a <- matrix(NA, nrow=K, ncol=S)
b <- matrix(NA, nrow=K, ncol=S)
for (s in 1:S) {
a[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
b[, s] <- rgamma(K, a_gamma, rate = 1/b_gamma)
}
# reorder a,b matrices to match ordering of means (U) in S1
U <- a/(a+b)
V <- a+b
U.ordered <- U[order(U[,1]), ]
a.ordered <- a[ordered(U[,1]),]
b.ordered <- b[ordered(U[,1]),]
V.ordered <- V[ordered(U[,1]),]
pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)
w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
w[, s] <- rbeta(I, a.ordered[,s][z], b.ordered[,s][z])
}
tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)
calcTheta <- function(m, tcn, w) {
(m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)
n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
for (s in 1:S) {
y[i, s] <- rbinom(1, n[i, s], theta[i,s])
}
}
#n_S2 <- subset(n, select = 2)
#y_S2 <- subset(y, select = 2)
#m_S2 <- subset(m, select = 2)
#tcn_S2 <- subset(tcn, select = 2)
n_S4 <- n[ , 4]
y_S4 <- y[ , 4]
m_S4 <- m[ , 4]
tcn_S4 <- tcn[ , 4]
w_S4 <- w[ ,4]
S <- 1
jags.file <- file.path(models.dir, "v2_uv_unif_fix2_1sample.jags")
test.data <- list("I" = I, "K" = K,
"y" = y_S4, "n" = n_S4,
"m" = m_S4, "tcn" = tcn_S4)
jags.m <- jags.model(jags.file, test.data,
n.chains = 1,
inits = list(".RNG.name" = "base::Wichmann-Hill",
".RNG.seed" = 123))
params <- c("z", "w", "U", "V")
samps <- coda.samples(jags.m, params, n.iter=6000, thin = 6)
effectiveSize(samps)
samps
?mcmc.list
x <- plot(samps)
str(x)
samps[[1]]
str(samps[[1]])
samps[[1]]$chr
U_trace <- samps[[1]][, 1:2]
U_trace
head(U_trace)
V_trace <- sampe[[1]][, 3:4]
V_trace <- samps[[1]][, 3:4]
head(V_trace)
str(U_trace)
traceplot(U_trace)
plot(U_trace)
traceplot(U_trace)
traceplot(U_trace[1])
traceplot(U_trace[,1])
plot(U_trace, ylim = c(0,1))
traceplot(U_trace[,1], ylim = c(0,1))
line(U_trace[,2])
max(V_trace)
min(V_trace)
install.packages(bayesplot)
install.packages("bayesplot")
install.packages("bayesplot")
library(bayesplot)
mcmc_trace(U_trace)
mcmc_trace(U_trace, regex_pars = "U")
UV_trace <- samps[[1]][, 1:4]
mcmc_trace(UV_trace, pars = c("U", "V"))
mcmc_trace(UV_trace, regex_pars = c("U", "V"))
dimnames(UV_trace)
U_trace
UV_trace <- list(samps[[1]][, 1],
samps[[1]][, 2]
samps[[1]][, 3]
UV_trace <- list(samps[[1]][, 1],
samps[[1]][, 2],
samps[[1]][, 3],
samps[[1]][, 4])
UV_trace <- list(samps[[1]][, c(1,3)],
samps[[1]][, c(2,4)])
head(UV_trace)
mcmc_trace(UV_trace, regex_pars = c("U", "V"))
str(samps[[1]][, c(1,3)])
dimnames(samps[[1]][, c(1,3)])
x1 <- samps[[1]][, c(1,3)]
dimnames(x1)[[2]] <- c("U", "V")
x1 <- samps[[1]][, c(1,3)]
dimnames(x1)[[2]] <- c("U", "V")
x2 <- samps[[1]][, c(2,4)]
dimnames(x2)[[2]] <- c("U", "V")
UV_trace <- list(x1, x2)
dimnames(UV_trace)
head(UV_trace)
str(UV_trace)
mcmc_trace(UV_trace, regex_pars = c("U", "V"))
mcmc_trace
