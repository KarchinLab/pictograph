---
title: "Version 3: 3 clusters"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(coda)
library(MCMCpack)
library(bayesplot)

working.dir <- "~/Dropbox/Wood-Collab-Progression/clustering/v3"
models.dir <- file.path(working.dir, "models")
trace.dir <- file.path(working.dir, "trace")
dir.create(trace.dir, showWarnings = F)
runName <- "v3_K3_noConstraints_simByMode"
```

## Simulate data

```{r sim}
I <- 50
K <- 3
S <- 10

set.seed(123)

d <- matrix(NA, nrow=K, ncol=S)
c <- matrix(150, nrow=K, ncol=S)
for (s in 1:S) {
  d[, s] <- runif(K, 0.05, 1)
}

a <- d*(c-1)+1
b <- (1-d)*(c-2)+1

pi <- as.vector(rdirichlet(1, rep(1, K)))
z <- sample(1:K, size = I, replace = T, prob = pi)

w <- matrix(NA, nrow=I, ncol=S)
for (s in 1:S) {
  w[, s] <- rbeta(I, a[,s][z], b[,s][z])
}

tcn <- matrix(2, nrow=I, ncol=S)
m <- matrix(rep(sample(1:2, size = I, replace = T), S), nrow=I, ncol=S)

calcTheta <- function(m, tcn, w) {
  (m * w) / (tcn * w + 2*(1-w))
}
theta <- calcTheta(m, tcn, w)

n <- replicate(S, rpois(I, 100))
y <- matrix(NA, nrow=I, ncol=S)
for (i in 1:I) {
  for (s in 1:S) {
    y[i, s] <- rbinom(1, n[i, s], theta[i,s])
  }
}
```

## JAGS

```{r JAGS}
jags.file <- file.path(models.dir, "v3_noConstraints_mode.jags")

test.data <- list("I" = I, "S" = S, "K" = K, 
                  "y" = y, "n" = n,
                  "m" = m, "tcn" = tcn)
jags.m <- jags.model(jags.file, test.data,
                     n.chains = 1,
                     inits = list(".RNG.name" = "base::Wichmann-Hill", 
                                  ".RNG.seed" = 12))
params <- c("z", "w", "d", "c")
samps <- coda.samples(jags.m, params, n.iter=6000, thin=5)
s <- summary(samps)
effectiveSize(samps)
pdf(file.path(trace.dir, paste0(runName, "_trace.pdf")))
plot(samps)
dev.off()
```

```{r plots}
mcmc_cals <- s$statistics
mcmc_w <- mcmc_cals[substr(rownames(mcmc_cals), 1, 1) == "w", "Mean"]
plot(as.vector(w), mcmc_w, type = "p")
abline(a=0, b=1)

mcmc_z <- as.vector(mcmc_cals[substr(rownames(mcmc_cals), 1, 1) == "z", "Mean"])
#mcmc_z <- round(mcmc_z, 0)
plot(z, mcmc_z, type = "p")

mcmc_d<- mcmc_cals[substr(rownames(mcmc_cals), 1, 1) == "d", "Mean"]
mcmc_d <- matrix(mcmc_d, nrow=K)
mcmc_c <- mcmc_cals[substr(rownames(mcmc_cals), 1, 1) == "c", "Mean"]
mcmc_c <- matrix(mcmc_c, nrow=K)

mcmc_a <- mcmc_d*(mcmc_c-1)+1
mcmc_b <- (1-mcmc_d)*(mcmc_c-2)+1

p <- seq(0, 1, length = 100)
colors <- c("#000000", "#DCA200", "#8FA7ED", "#9D847A", "#A47901")
for (s in 1:S) {
  for (k in 1:K) {
    if (k == 1) {
      # plot mcmc 
      plot(p, dbeta(p, mcmc_a[k,s], mcmc_b[k,s]), 
           main = paste0("S", s), 
           ylab = "density", xlab = "w", type = "l", col = colors[k],
           ylim = c(0, 20))
      # plot truth
      lines(p, dbeta(p, a[k,s], b[k,s]), type = "l", col = colors[k], lty=2)
      # add legend
      allU <- round(as.vector(rbind(mcmc_d[,s], d[,s])), digits = 2)
      legend(x = "topleft", 
             legend = paste0(c("mean k", "true k"), rep(1:K, each=2), ", mode = ", allU),
             col = colors[rep(1:K, each=2)],
             lty = rep(1:2, K),
             cex=0.8)
    } else {
      # plot mcmc 
      lines(p, dbeta(p, mcmc_a[k,s], mcmc_b[k,s]), 
            type = "l", col = colors[k])
      # plot truth
      lines(p, dbeta(p, a[k,s], b[k,s]), type = "l", col = colors[k], lty=2)
    }
  }
}

```

